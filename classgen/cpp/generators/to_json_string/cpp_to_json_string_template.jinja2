{% macro value_to_string(field_type, field_name, this = True) %}
    {% set this = "this->" if this == True else "" %}
    {% set this_field = this + field_name %}
    {##}
    {% if is_numerical(field_type) %}
        {% if is_floating_point(field_type) %}
            [](const double v) { const auto vs = std::to_string(v); return vs.find_first_of('.') != std::string::npos ? vs : vs + ".0"; }({{this_field}})
        {% else %}
        {{this_field}}
        {% endif %}
    {% elif is_string(field_type) %}
        "\"" << {{this_field}} << "\""
    {% elif is_bool(field_type) %}
        ({{this_field}} == true ? "true" : "false")
    {% elif is_str_or_class(field_type) %}
        {{this_field}}.{{function_name}}()
    {% elif is_string_view(field_type) %}
        "\"" << {{this_field}} << "\""
    {% elif is_map(field_type) or is_set(field_type) %}
        {{field_name}}
    {% elif is_user_defined(field_type) %}
        {{this_field}}.{{function_name}}()
    {% else %}
        NON IMPLEMENTED FIELD IN TO STRING GENERATOR
    {% endif %}
{% endmacro %}
{##}
{##}
{##}
{##}
{% macro map_to_lambda(map_type, map_name) %}
[this](const std::string_view current_indent, const size_t indent_size) -> std::string {
    const std::string indent = std::string(current_indent) + std::string(current_indent);
    std::stringstream result;
    result << "{\n";
    size_t loop_index = 0;
    for (const auto& [key, value] : this->{{map_name}}) {
        result << indent << {{value_to_string(map_type.key_type, 'key', False)|trim}};
        result << " : ";
        result << {{value_to_string(map_type.value_type, 'value', False)|trim}};
        if (loop_index++ != this->{{map_name}}.size() - 1) {
            result << ",\n";
        } else {
            result << "\n";
        }
    }
    result << current_indent;
    result << "}";
    return result.str();
}(indent, indent_size)
{% endmacro %}
{##}
{##}
{##}
{##}
{##}
{% macro set_to_lambda(set_type, set_name) %}
[this](const std::string_view current_indent, const size_t indent_size) -> std::string {
    const std::string indent = std::string(current_indent) + std::string(current_indent);
    std::stringstream result;
    result << "[\n";
    size_t loop_index = 0;
    for (const auto& value : this->{{set_name}}) {
        result << indent << {{value_to_string(set_type.value_type, 'value', False)|trim}};
        if (loop_index++ != this->{{set_name}}.size() - 1) {
            result << ",\n";
        } else {
            result << "\n";
        }
    }
    result << current_indent;
    result << "]";
    return result.str();
}(indent, indent_size)
{% endmacro %}
{##}
{##}
{##}
{% macro generate_templated_type_lambda(field) %}
{% if is_map(field) %}
{{map_to_lambda(field.type, field.name)|trim}}
{% elif is_set(field) %}
{{set_to_lambda(field.type, field.name)|trim}}
{% else %}
NON IMPLEMENTED FIELD IN TO TEMPLATE TO STRING GENERATOR
{% endif %}
{% endmacro %}
{##}
{##}
{##}
{##}
std::string {{function_name}}(const size_t indent_size = {{default_indent_size}}) const {
    const std::string indent(indent_size, ' ');

    {% for field in templated_fields %}
    const std::string {{field.name}} = {{ generate_templated_type_lambda(field)|indent(4)|trim}};

    {% endfor %}
    std::stringstream result;
    result << "{\n";
    {% for field in all_fields if not field.static %}
    {% set end_of_block = ' << ",\\n";' if loop.revindex0 != 0 else ';'%}
    result << indent << "\"{{field.name}}\": " << {{ value_to_string(field.type, field.name)|trim }}{{end_of_block}}
    {% endfor %}
    result << "\n}";
    return result.str();
}